# dkbparse
PDF parser for DKB bank and VISA statements

## Features
- Can be used as shell script
- CSV export
- Automatic tagging of transactions based on regular expressions
- Manual tagging of transactions based on annotations

## Requirements
You will need to have Python 3 and pdftotext installed.

## Usage

### Shell Script
You can run `dkbparse.py` as shell script and pass a list of directories that contain DKB PDF statements. The script will write all parsed transactions as CSV to stdout:
```bash
$ ./dkbparse.py ~/dkb/account/1234567890/ ~/dkb/visa/4998xxxxxxxx1234/ > transactions.csv
```

### Library
Alternatively, you can pass a list of direcotries that contains DKB PDF files (VISA and/or bank statements) to `dkbparse.scan_dir()`. All directories are scanned recursively. The function returns a list of transactions and a list of bank statements that were parsed:

```python
import os
from dkbparse import scan_dir

# folder with DKB PDFs
dirpath = os.path.expanduser('~/dkb/visa/4998xxxxxxxx1234') 
transactions, statements = dkbparse.scan_dirs([dirpath])
```
# 
A transaction dict looks like this
```
{
    'account': '1234567890', 
    'statement': '1/2019', 
    'booked': datetime.date(2019, 1, 2), 
    'valued': datetime.date(2018, 12, 31), 
    'type': 'Überweisung', 
    'value': Decimal('-250.00'), 
    'tags': [],
    'comment': 'ÜBERWEISUNG DATUM 29.12.2018, 05.33 UHR 1.TAN 123456'
}
```

A statement dict looks like this
```
{   
    'account': '9451359782',
    'balance_new': Decimal('487.33'),
    'balance_old': Decimal('1443.81'),
    'from': datetime.datetime(2018, 12, 29, 0, 0),
    'iban': 'DE82 1234 0000 9451 3597 82',
    'no': 1,
    'to': datetime.datetime(2019, 1, 3, 0, 0),
    'year': 2019
}
```

The script will output an error if the sum of all transactions of a statement does not correspond to the stated balance difference. This will help you to identify cases where the parser fails to parse a statement.

## Tagging

Tags can be added **automatically** (based on regular expressions applied to `comment`), or **manually** (based on annotations - copies of transactions with added tags). 

The regular expressions for automatic tagging are defined in a hierarchical yaml file with the following format:
```yaml
assets:
    checkings:
    savings:
equity:
expenses:
    clothes:
        esprit: ^ESPRIT
        h-and-m: (^H&M)|(H\+M)
    misc:
income:
liabilities:
```
In this case, if a transaction comment would match `^ESPRIT`, the tagger would apply the tags `['esprit', 'clothes', 'expenses']` to that transaction

Annotations are defined in a csv file file the following format:
```csv
account,statement,booked,valued,type,value,tags,comment
1234567890,1/2019,2019-01-02,Überweisung,-250,misc,ÜBERWEISUNG DATUM 29.12.2018, 05.33 UHR 1.TAN 123456
```
This format corresponds with the format generated by `transactions_to_csv()`. The tagger automatically applies parent tags as defined in the yaml, so the resulting tags in the given example would be `['misc', 'expenses']`.

When used as a shell script, regular expressions for automatic tagging are loaded from `dkbparse/tags-auto.yaml` (if present) and annotations are loaded from `dkbparse/tags-manual.csv` (if present).

## Performance

The script scans around 100 PDF files (or 2500 transactions) per second.

## Limitations

The main limitation of this approach is that the output depends on the version of the installed `pdftotext` ([Poppler](https://poppler.freedesktop.org/)). Different results on different platforms can not be excluded. For example, using pdftotext version 0.86.1, I occasionally get the following error, which appears to be a known issue.
```
Syntax Warning: FoFiType1::parse a line has more than 255 characters, we don't support this
```